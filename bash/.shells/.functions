############## FUNCTIONS OPTIONS ################

# Переопределяем команду cd и добавляем автоактивацию venv
function cd() {
  builtin cd "$@"
  if [[ -z "$VIRTUAL_ENV" ]] ; then
      # Если папка venv найдена, активирует vitualenv
      if [[ -d ./.venv ]] ; then
        source ./.venv/bin/activate
      fi
  else
      # проверяет, принадлежит ли текущая папка более ранней папке VIRTUAL_ENV
      # если да, то ничего не делайте
      # или деактивировать
      parentdir="$(dirname "$VIRTUAL_ENV")"
      if [[ "$PWD"/ != "$parentdir"/* ]] ; then
        deactivate
      fi
  fi
}

# Показывает список (20 первых) самых больших файлов в каталоге
function find_largest_files() {
    du -h -x -s -- * | sort -r -h | head -20;
}

function print_ip_adress(){
	# 2>/dev/null - убирает вывод таблицы curl запроса в консоль. Только ip
	get_ip=$(curl ifconfig.me 2>/dev/null);
	echo "Мой IP адресс: $get_ip";
}

# Инициализация проекта (каталога и шаблонов гит файлов)
# Аргументом принимает название директории
function git_init() {
    if [ -z "$1" ]; then
        printf "%s\n" "Укажите имя директории 'comand name_dir'";
    else
        mkdir "$1";
        builtin cd "$1";
        pwd;
        git init;
        touch readme.md .gitignore LICENSE;
        echo "# $(basename $PWD)" >> readme.md;
    fi
}

function see_vpn_is_active() {
	# задаём переменную в которой ищем запущен ли wireguard
  # -c считает количество упоминаний
	isactive=$(sudo wg show | grep -c wg0);
	if sudo wg show | grep -c wg0 2>&1 >/dev/null; then
		# /dev/null 2>&1 - отключает вывод у указанного уровня (2 и 1) вывода в терминал
		wg-quick down wg0 > /dev/null 2>&1 && echo "VPN Deactivate";
	# если переменная equal (равна) False
	elif [ $isactive -eq 0 ]; then
		wg-quick up wg0 > /dev/null 2>&1 && echo "VPN Activate";
	fi
}

# Функция разархивации, автоматически определяющая нужную команду
# из переданного названия файла в качестве аргумента
function extract () {
  if [ -f $1 ] ; then
      case $1 in
          *.tar.bz2)   tar xvjf $1    ;;
          *.tar.gz)    tar xvzf $1    ;;
          *.bz2)       bunzip2 $1     ;;
          *.rar)       rar x $1       ;;
          *.gz)        gunzip $1      ;;
          *.tar)       tar xvf $1     ;;
          *.tbz2)      tar xvjf $1    ;;
          *.tgz)       tar xvzf $1    ;;
          *.zip)       unzip $1       ;;
          *.Z)         uncompress $1  ;;
          *.7z)        7z x $1        ;;
          *)           echo "Невозможно разархивироватьь  '$1'..." ;;
      esac
  else
      echo "'$1' не верный файл!"
  fi
}


function mount_webdav() {
  # Проверяем, существуют ли целевые директории монтирования, и, если нет, создаем их.
  if [ ! -d "$WEBDAV_DIR" ]; then
    echo "Создание $WEBDAV_URL";
    mkdir $WEBDAV_URL;
  fi
  # Монтируем WebDAV каталоги
  echo "Монтирование $WEBDAV_URL";
  sudo mount -t davfs -o rw $WEBDAV_URL $WEBDAV_DIR;
  cd $WEBDAV_DIR;
  pwd;
}

# Принимает на вход два аргумента:
# $1 - файл (архив) для бэкапа
# $2 - директорию, куда нужно сохранить бэкап
function backup_zip_file_on_mailcloud() {
  CURRENT_DIR=$(pwd);
  NAME_DIR=$(date +"%d.%m.%Y");
  FILE_BACKUP="$1/$2";
  DIR_BACKUP=$3;  
  cd $DIR_BACKUP;
  if [ ! -d "$NAME_DIR" ]; then
    sudo mkdir $NAME_DIR;
    echo "Создана новая директория $NAME_DIR";
  else
    echo "Переход в директорию $NAME_DIR";
  fi
  CLOUD_DIR="$3/$NAME_DIR/";
  echo "Переносим $FILE_BACKUP в: $NAME_DIR";
  sudo mv $FILE_BACKUP $CLOUD_DIR;
  echo "Перенос завершён!";
  cd $CURRENT_DIR;
}

function unmount_webdav() {
  # Размонтирование WebDAV
  echo "Размонтирование $WEBDAV_URL";
  sudo umount $WEBDAV_DIR;
  # После размонтирования, удаляем пустой каталог
  # rm -r $WEBDAV_DIR;
  cd ~;
}

# В первом аргументе передоётся имя файла "obsidian.zip"
# Во втором аргументе - директория или файл для архивации
function zip_files(){
  NAME_ZIP=$1;
  DIR_FOR_ZIP=$2;
  CURRENT_DIR=$(pwd);
  cd $DIR_FOR_ZIP;
  if [ -e "$NAME_ZIP" ]; then
    rm $NAME_ZIP;
    echo "Прошлый архив удалён!"
  fi
  echo "Приступаем к архивации..."
  zip -r $NAME_ZIP $DIR_FOR_ZIP > /dev/null 2>&1;
  iscreate=$(ll -la | grep -c $NAME_ZIP);
  if [ ! $iscreate -eq 0 ]; then
    echo "Архив $NAME_ZIP создан!";
    pwd;
  fi
  cd $CURRENT_DIR;
}
